[{"content":"已删\n","date":"2025-02-22T00:24:53+08:00","permalink":"https://lcx823.github.io/lcx823/p/%E6%9D%82%E8%AE%B001/","title":"杂记01"},{"content":"java全栈体系-星云 著作权归 @星云系 所有。 链接：https://blog.xygalaxy.com/\nSpring概览 容器框架 Spring 是一个容器，用于存放java对象 Spring容器可以管理对象的创建和对象之间的关系 从容器中获取要使用的对象 优势与特性 轻量级：Spring 框架相比于 EJB 和其他重量级框架，轻量级许多，不需要过多的资源消耗。\n控制反转（IOC）：Spring 框架通过 IoC 实现了对象的创建和管理，解耦了对象与对象之间的依赖关系。\n依赖注入（DI）：Spring 框架通过 DI 提供了对象之间的依赖关系，使得对象更加独立，组织起来更有序。\n面向切面编程（AOP）：Spring 框架的 AOP 模块直接将面向切面编程集成到了 Spring 容器中，能够方便地解决业务处理中的横切问题。\n易于测试：Spring 框架对 JUnit4 进行了支持，通过 Spring 的测试类，Spring 可以很方便地进行测试驱动开发（TDD）。\n面向接口编程：Spring 框架鼓励程序员进行面向接口编程，这不仅有助于降低程序间的耦合，还能提高程序的可扩展性。\n容器：Spring 框架就是一个容器，因为它包含并管理应用对象的生命周期和配置。\n异常处理：Spring 提供了一个方便的 API 来翻译技术级别的异常（如 SQLException、HibernateException 等）为一致的、未检查的异常。\n集成其他框架：Spring 并不排斥其他的开源 Java 框架。实际上，Spring 可以很容易地与 Hibernate，Struts，JSF 等框架集成。\n支持事物管理：Spring 提供一种统一的事务管理接口，可以支持各种事务管理，无论是本地事务还是全局事务。\n解耦合\n什么是耦合\n程序之间的依赖性\n什么是依赖\nClass A 中使用了Class B的属性或者方法，叫做Class A 依赖 Class B\n都有什么耦合\n类之间的依赖，方法之间的依赖\n解耦合使得系统中的各个模块或组件可以独立开发、测试、维护和扩展。\nSpring如何解耦合\n第一步：使用反射机制创建对象，而不是new关键字\n第二步：通过读取配置文件来获取要创建的对象的全限定类名\nSpring管理哪些对象\ndao类，service类，controller类，工具类等适合把对象放到容器中。\nspring对象默认都是单例的（在容器中叫这个名称的对象就只有一个）。\n实体类对象，servlet、监听器、过滤器等不放入到spring容器中的对象。\nIOC控制反转与DI依赖注入 IOC理解 IOC是什么\nIOC（Inversion of Control）即：控制反转，不是一种技术，是一种设计思想。\n控制反转的理解\n把对象的创建，赋值，管理工作都交给代码之外的容器实现，也就是对象的创建是有其他的外部资源来完成的。 控制是指控制对象的创建、对象的属性赋值、对象之间的依赖关系管理。 反转是指把控制权交给容器，也就是把对象交给容器来管理。用容器代替开发人员的管理、创建、赋值等。 正转是指开发人员使用new创建对象，用set方法设置属性，通过手动实现依赖关系管理。 控制反转理解起来就是：容器代替了开发人员对于对象的创建、赋值、依赖关系管理。 Spring中IOC的理解\nSpring把管理的对象叫做Bean，即由开发人员管理Bean转变为Spring管理Bean，这就是Spring的控制反转（IOC）。 Spring把这些管理的Bean放到容器中，这容器即：IOC容器（IOC Container）。 Spring管理Bean是通过配置的方式来实现的，Spring提供了三种Bean配置方式：基于XML的配置方式、基于Java的配置方式、基于注解的配置方式。 Spring管理了Bean，就必然要管理Bean的整个生命周期。 程序从IOC容器中获取Bean，并注入到程序中使用，这个过程就是依赖注入（DI）。所以说控制反转是通过依赖注入实现的。即：IOC是设计思想，DI是实现方式。 依赖注入的方式也有三种：setter方式、构造器注入、注解注入。 Spring Bean Spring Bean是一个由Spring框架管理的Java对象。在Spring应用程序中，Bean是一个由IOC容器创建、组装和管理的对象。\nBean的装配 基于XML的配置方式 顾名思义，就是将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--告诉spring创建对象 声明bean，告诉spring要创建哪个类的对象 id：对象的自定义名称，自己给对象起个名 class：类的全限定名称（不能是接口） --\u0026gt; \u0026lt;!-- 一个Bean 声明一个对象 --\u0026gt; \u0026lt;bean id=\u0026#34;userPo\u0026#34; class=\u0026#34;com.xygalaxy.po.UserPO\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;02\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;xygalaxy\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;sex\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 基于java的配置方式 注解@Configuration，声明该类为配置类\n创建一个方法返回创建的对象，并在该方法加上@Bean注解，声明这是一个Bean。\n通过AnnotationConfigApplicationContext读取配置类，获取Bean。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import com.xygalaxy.po.UserPO; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @ClassName HelloSpringConfig * @Description spring配置类 */ @Configuration public class HelloSpringConfig { @Bean(\u0026#34;helloUserPo\u0026#34;) public UserPO getUserPO(){ UserPO userPO = new UserPO(); userPO.setId(\u0026#34;1\u0026#34;); userPO.setName(\u0026#34;张三\u0026#34;); userPO.setAge(\u0026#34;20\u0026#34;); userPO.setSex(\u0026#34;男\u0026#34;); return userPO; } } // 测试 @Test public void testHelloSpring3(){ ApplicationContext ac = new AnnotationConfigApplicationContext(HelloSpringConfig.class); UserPO userPo = (UserPO) ac.getBean(\u0026#34;helloUserPo\u0026#34;); System.out.println(userPo); // UserPO(id=1, name=张三, age=20, sex=男) } 基于注解的配置方式 通过在类中添加注解，我们可以声明一个类由Spring进行管理。Spring会自自动搜索带有@Component，@Controller，@Service，@Repository四个注解的类，然后为我们创造并管理它们。前提是我们需要先配置Spring的注解扫描器，通过@ComponentScan配置注解扫描。\n增加一个配置类，用于配置扫描器，让Spring扫描po这个包下的所有注解\n1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; /** * @ClassName HelloSpringScanConfig * @Description 声明配置类，并扫描指定包 */ @Configuration @ComponentScan(\u0026#34;com.xygalaxy.po\u0026#34;) public class HelloSpringScanConfig { } UserPO类添加@Component注解，声明这个类直接给Spring管理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import lombok.Data; import org.springframework.stereotype.Component; /** * @ClassName UserPO * @Description 用户实体 */ @Data @Component public class UserPO { /** * id */ private String id; /** * 姓名 */ private String name; /** * 年龄 */ private String age; /** * 性别 */ private String sex; } 测试获取UserPo的Bean对象。\n1 2 3 4 5 6 7 8 9 @Test public void testHelloSpring4(){ ApplicationContext ac = new AnnotationConfigApplicationContext(HelloSpringScanConfig.class); UserPO userPo = (UserPO) ac.getBean(\u0026#34;userPO\u0026#34;); System.out.println(userPo); // UserPO(id=null, name=null, age=null, sex=null) } 因为我们只是在UserPO实体类上加了@Component注解，只是声明这个类为Bean，给IOC管理，并未赋值操作，所以这里的值都是null。\n@Component，@Controller，@Service，@Repository这几个注解的区别和用法\n@Component:\n@Component是一个通用的注解，表示该类被标注为一个Spring管理的Bean，并且可以作为一个通用的组件被注入和使用。 在使用@Component注解标注类时，默认的Bean名称是类名的首字母小写，可以使用@Bean注解的name属性来自定义Bean名称。 @Controller:\n@Controller注解用于标注控制层的Bean，即MVC模式中的控制器。 通常用于处理HTTP请求、响应和路由控制等功能。 @Controller注解通常与@RequestMapping注解一起使用，用于指定请求的URL映射。 @Service:\n@Service注解用于标注服务层的Bean，即用于标识业务逻辑的组件。 主要用于标识业务逻辑的处理，如事务管理、数据处理等。 @Service注解通常与@Autowired注解一起使用，用于自动注入依赖的其他Bean。 @Repository:\n@Repository注解用于标注数据访问层（DAO）的Bean。 主要用于标识数据访问相关的类，如数据存取、数据库操作等。 与@Service注解一样，@Repository注解通常与@Autowired注解一起使用，用于自动注入依赖的其他Bean Bean的装配策略 Byname自动装配：保证所有bean的id唯一 ，并且这个bean需要和自动注入的属性的set方法的值一致。\n//autowire = \u0026ldquo;byName\u0026quot;可以省略\nBytag自动装配：保证所有bean的class唯一 ，并且这个bean需要和自动注入的属性的类型一致；全局唯一，id属性可以省略。这里class就是该bean的属性类型\n//id = \u0026ldquo;userPo\u0026quot;可以省略\nDI理解 DI（依赖注入）是创建对象，并给属性赋值，注入就是赋值的意思。\nDI注入 setter方式 在类中提供需要注入成员的set方法\n在xml方式中，property都是setter方式注入。通过property标签给指定属性赋值。\n1 2 3 4 5 6 \u0026lt;bean id=\u0026#34;userPo\u0026#34; class=\u0026#34;com.xygalaxy.po.UserPO\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;02\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;xygalaxy\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;sex\u0026#34; value=\u0026#34;男\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 构造器注入 使用类中的构造函数，给成员变量赋值。\n通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。\n在XML配置方式中，\u0026lt;constructor-arg\u0026gt;是通过构造函数参数注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!--默认构造器方式--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.xygalaxy.po.UserPO\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;张三\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--通过有参构造创建对象。方式一：下标赋值--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.xygalaxy.po.UserPO\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;jerry\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--通过有参构造创建对象。方式二：类型创建，不建议使用--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.xygalaxy.po.UserPO\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;jarry\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--通过有参构造创建对象。方式三：通过参数名，推荐使用--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.xygalaxy.po.UserPO\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;jarry\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;birthday\u0026#34; ref=\u0026#34;now\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置一个日期对象 --\u0026gt; \u0026lt;bean id=\u0026#34;now\u0026#34; class=\u0026#34;java.util.Date\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 注解注入 通过注解的方式进行赋值。\n以@Autowired（自动注入）注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。\n注入Service\n1 2 3 4 5 6 7 8 // 将Service交给Spring容器管理 @Service public class HelloSpringServiceImpl implements HelloSpringService { } // 通过@Autowired自动注入到helloSpringService中，就可以直接使用了 @Autowired private HelloSpringServiceImpl helloSpringService; 其他属性注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 复杂类型的注入 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;person\u0026#34; class=\u0026#34;com.xygalaxy.UserPo\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;zhangsan\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;12\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;com.kang.pojo.Student\u0026#34;\u0026gt; \u0026lt;!--普通值注入，value：具体属性值--\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;jerry\u0026#34;/\u0026gt; \u0026lt;!--Bean注入，ref：对象--\u0026gt; \u0026lt;property name=\u0026#34;person\u0026#34; ref=\u0026#34;person\u0026#34;/\u0026gt; \u0026lt;!--数组注入--\u0026gt; \u0026lt;property name=\u0026#34;arr\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;AAA\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;BBB\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;CCC\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--List注入--\u0026gt; \u0026lt;property name=\u0026#34;myList\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;111\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;222\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;333\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Map注入--\u0026gt; \u0026lt;property name=\u0026#34;myMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;aaa\u0026#34; value=\u0026#34;aaaa\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;bbb\u0026#34; value=\u0026#34;bbbb\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;ccc\u0026#34; value=\u0026#34;cccc\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Set注入--\u0026gt; \u0026lt;property name=\u0026#34;mySet\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;111\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;222\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;333\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null注入--\u0026gt; \u0026lt;property name=\u0026#34;wife\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--Properties注入--\u0026gt; \u0026lt;property name=\u0026#34;myPro\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;aaa\u0026#34;\u0026gt;aaaa\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;bbb\u0026#34;\u0026gt;bbbb\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;ccc\u0026#34;\u0026gt;cccc\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 p、c命名空间的注入 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--p命名空间注入，可以直接注入属性的值：properties--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.xygalaxy.UserPo\u0026#34; p:name=\u0026#34;jarry\u0026#34; p:age=\u0026#34;15\u0026#34;/\u0026gt; \u0026lt;!--c命名空间注入，通过构造器注入：construct-args--\u0026gt; \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;com.xygalaxy.UserPo\u0026#34; c:name=\u0026#34;张三\u0026#34; c:age=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 bean作用域 \u0026lt;!-- 单例模式（Spring默认的机制） --\u0026gt; \u0026lt;bean id=\u0026#34;helloSpringService\u0026#34; class=\u0026#34;com.xygalaxy.service.HelloSpringService\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; \u0026lt;!-- 原型模式（多例模式） --\u0026gt; \u0026lt;bean id=\u0026#34;helloSpringService\u0026#34; class=\u0026#34;com.xygalaxy.service.HelloSpringService\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; \u0026lt;!--注解方式开启 --\u0026gt; @Scope(\u0026#34;prototype\u0026#34;) AOP面向切面编程 AOP的引入\n传统的面向对象编程（OOP）通过将相关功能封装到类中，使得代码更加模块化和可维护。然而，当系统中的某些关注点（如日志、事务、安全等）需要横跨多个类时，OOP 的封装机制会变得复杂且难以维护。\nAOP 通过将这些横切关注点称为切面（Aspect），并将它们与主业务逻辑进行分离，实现了关注点的重用和集中管理。切面是一组跨越多个对象的通用行为集合，可以通过切点（Pointcut）来定位横切的位置，并通过增强（Advice）在指定的切点上执行额外的行为。\nAOP的实现： Spring AOP和AspectJ。\nSpring框架配置简化过程 XML配置方法 -\u0026gt; Java配置方式 -\u0026gt; 注解配置方式 -\u0026gt; SpringBoot托管配置方式\nXML配置 创建接口及实现\n1 2 3 4 5 6 7 8 9 10 11 12 // 接口 public interface AopService { public void sayOne(); } // 实现 public class AopServiceImpl implements AopService { @Override public void sayOne() { System.out.println(\u0026#34;这是One语句\u0026#34;); } } 创建aopSpring.xml配置文件\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;aopServiceImpl\u0026#34; class=\u0026#34;com.xygalaxy.service.impl.AopServiceImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 测试获取aopServiceImpl对象\n1 2 3 4 5 6 7 8 9 10 11 12 public class AopController { @Test public void testAop(){ ApplicationContext ac = new ClassPathXmlApplicationContext(\u0026#34;aopSpring.xml\u0026#34;); AopServiceImpl aopService = ac.getBean(AopServiceImpl.class); aopService.sayOne(); } } /** * 输出结果：这是One语句 */ 著作权归 @星云系 所有。 链接：https://blog.xygalaxy.com/后端/Java/Java框架/Spring/4.Spring框架配置简化过程.html\njava配置 创建接口及实现\n1 2 3 4 5 6 7 8 9 10 11 12 // 接口 public interface AopService { public void sayOne(); } // 实现 public class AopServiceImpl implements AopService { @Override public void sayOne() { System.out.println(\u0026#34;这是One语句\u0026#34;); } } 创建配置类\n1 2 3 4 5 6 7 8 9 10 @Configuration public class AopConfig { @Bean(\u0026#34;aopServiceImpl\u0026#34;) public AopServiceImpl getAopService(){ AopServiceImpl aopService = new AopServiceImpl(); return aopService; } } 测试获取aopServiceImpl对象\n1 2 3 4 5 6 7 8 9 10 11 12 public class AopController { @Test public void testAop(){ ApplicationContext ac = new AnnotationConfigApplicationContext(AopConfig.class); AopServiceImpl aopService = ac.getBean(AopServiceImpl.class); aopService.sayOne(); } } /** * 输出结果：这是One语句 */ 注解配置 创建接口及实现\n增加注解@Service，交给Spring管理\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 接口 public interface AopService { public void sayOne(); } // 实现 @Service public class AopServiceImpl implements AopService { @Override public void sayOne() { System.out.println(\u0026#34;这是One语句\u0026#34;); } } 测试获取aopServiceImpl对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 单元测试需要加@RunWith注解，正常应用中不需要 @RunWith(SpringJUnit4ClassRunner.class) public class AopController { @Autowired private AopServiceImpl aopService; @Test public void testAop(){ aopService.sayOne(); } } /** * 输出结果：这是One语句 */ SpringBoot托管配置 Spring Boot是一个开源的Java框架，它简化了基于Spring平台开发应用程序的过程。它提供了预设的模板，通过自动配置（auto-configuration）和约定大于配置（convention-over-configuration）的原则降低了开发者的配置负担。这让开发者可以专注于应用程序的功能开发，提高了开发效率。\nSpring事务 编程式 声明式 @Transactional(propagation = Propagation.REQUIRED)\nSpring MVC 前提\n对Spring有一定了解 对JavaWeb有一定了解 对Servlet有一定了解 mybatis mybatisplus ssm ","date":"2025-02-20T20:50:54+08:00","permalink":"https://lcx823.github.io/lcx823/p/java-ssm/","title":"Java SSM"}]